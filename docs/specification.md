Building LIS PackagesFeature Summary:    This document describes how we intent to build the LIS packages using our Docker containers.  This includes details on the flavors we intend to generate as well as the mechanism used to trigger new builds to generate the appropriate packages.1. Problem Statement and Value Props   1.1. Elevator Pitch        Using our build system, we can create all artifacts for a given update.  These artifacts (RPMs and DEB files) can be generated when source is committed or a pull request is created.  Upon notification, all completed flavors can be constructed and made available to a testing infrastructure which can then generate a result set given appropriate tests.   1.2. Milestones        (  ) -- Centos 7.x, Github repo created.  Functional Specification.  Jenkins jobs for building.        (  ) -- Deb inclusion2. Feature Summary   2.1. Deployable    A deployable solution is beneficial both in that is it easily recoverable in the case of a system failure and that is can be easily executed via automation.      2.1.1. Github            All artifacts and supporting scripts can be found in one location: https://github.com/openstack-hyper-v/LIS-Build-Packages.git      2.1.2. Docker files            Docker files for each distribution, RPM or DEB, are constructed and stored in Github.      2.1.3. Jenkins Jobs            Jenkins jobs are stored as XML files in Github which can be retrieved and added to a Jenkins instance using the Jenkins CLI.   2.2. Identifiable        All produced RPMs and DEBs will contain a modified version number where the source is noted.  For instance, from the Cambridge lab, an RPM with a version 4.1.1 would present as 4.1.1.Cambridge.        All sources for constructing and using the array of build containers in the github repository’   2.3. Internal Store        An internal store will contain the results of successful builds and update as new builds are updated.  This takes the form of metadata pushed to a yum or apt-get repository.3. Functionality and Production   3.1. User Workflow(/workflow.png)   3.2. Feature Details      3.2.1. External Trigger for monitoring pull request      3.2.2. External Trigger for monitoring changeset check-in      3.2.3. Manual Trigger            A manual job will be created to start ALL the build jobs.  This can be executed from Jenkins directly.      3.2.4. Build <Particular Platform>            Job will build the appropriate Dockerfile.         3.2.4.1. Centos 7.0.1406         3.2.4.2. Centos 7.1.1503         3.2.4.3. Centos 7.2.1511      3.2.5. Push <RPM/DEB>            A successful Docker container will contain the resulting RPM or DEB which will be pushed to the internal store.4. Code Implementation Details   4.1. Build <Particular Platform>      4.1.1. Install Development Tools      4.1.2. Clone LIS sources            git clone https://github.com/LIS/lis-next      4.1.3. Tar LIS sources            tar -czf /root/rpmbuild/SOURCES/lis-next-rh6.tar.gz /lis-next      4.1.4. Retrieve SPEC file            Presently, this comes from email.  Seeking source, it’s not present in repo.      4.1.5. Augment Version number            Modify the version number of the release.  Example … for centos 7.2, we would edit https://github.com/LIS/lis-next/blob/master/hv-rhel7.x/hv/include/linux/hv_compat.h and append the lab name as shown below.            #define HV_DRV_VERSION	"4.1.2"             #define HV_DRV_VERSION	"4.1.2.LabName"      4.1.6. Create Directory Structure            /root/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}      4.1.7. Build RPM            cd /root/rpmbuild/SPEC            rpmbuild –bb *.spec   4.2. Push <RPM/DEB>        Add resulting package to configured internal yum or apt-get registry5. Test Details